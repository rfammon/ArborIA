
/**
 * audit_runner.cjs
 * Universal Diagnostic Probe for Single Page Applications
 * Generated by AuditIA
 * 
 * NOTE: This file uses the .cjs extension to ensure it runs correctly 
 * in both CommonJS and ES Module projects.
 */

const { chromium } = require('playwright');
const fs = require('fs');
const path = require('path');

(async () => {
  console.log('\x1b[36m%s\x1b[0m', 'ðŸš€ Starting Universal Diagnostic Probe...');
  
  const report = {
    critical: [],
    ui: [],
    logic: [],
    security: []
  };

  // Launch with a standard Desktop Viewport first
  const browser = await chromium.launch({ headless: false }); 
  const context = await browser.newContext({
    viewport: { width: 1280, height: 720 } 
  });
  const page = await context.newPage();

  // 1. Capture Console Errors
  page.on('console', msg => {
    if (msg.type() === 'error') {
      report.critical.push(`Console Error: ${msg.text()}`);
    }
  });

  page.on('pageerror', exception => {
    report.critical.push(`Uncaught Exception: ${exception.message}`);
  });

  page.on('requestfailed', request => {
    // Filter out some common non-critical failures (like analytics) if needed
    report.critical.push(`Failed Resource: ${request.url()} - ${request.failure().errorText}`);
  });

  try {
    // 2. Auto-Discovery
    const target = process.argv[2] || 'file://' + path.join(process.cwd(), 'index.html');
    console.log(`Targeting: ${target}`);
    
    await page.goto(target, { waitUntil: 'networkidle' });

    // --- DESKTOP ANALYSIS ---
    console.log('\x1b[33m%s\x1b[0m', 'running Desktop Analysis...');

    const buttons = await page.getByRole('button').all();
    const inputs = await page.getByRole('textbox').all(); 

    if (buttons.length === 0 && inputs.length === 0) {
      report.ui.push('Warning: No interactive elements (buttons or inputs) found. Is the page rendering?');
    }

    // Basic Visibility Check (Desktop)
    for (const btn of buttons) {
      const isVisible = await btn.isVisible();
      const text = await btn.textContent();
      if (!isVisible) {
        report.ui.push(`Desktop: Hidden Button detected: "${text?.trim() || 'Unlabeled'}" - Verify if this is intended.`);
      }
    }

    // 3. Logic & Input Stress Test (Desktop)
    const inputLocators = await page.locator('input, textarea').all();
    for (let i = 0; i < inputLocators.length; i++) {
        const input = inputLocators[i];
        if (await input.isVisible()) {
            const name = await input.getAttribute('name') || await input.getAttribute('id') || `Input_${i}`;
            const type = await input.getAttribute('type') || 'text';

            report.security.push(`Input "${name}" (Type: ${type}) is susceptible to XSS injection if not sanitized. Payload test: <script>alert(1)</script>`);

            if (type === 'number') {
                await input.fill('-100');
                const val = await input.inputValue();
                if (val === '-100') {
                    report.logic.push(`Input "${name}" accepts negative numbers (-100). Verify business logic.`);
                }
            }
        }
    }

    // 4. Form Submission (Desktop)
    const forms = await page.locator('form').all();
    if (forms.length > 0) {
        const submitBtn = await forms[0].locator('button[type="submit"], input[type="submit"]').first();
        if (await submitBtn.count() > 0 && await submitBtn.isVisible()) {
             // Just checking existence, actual submit might navigate away, breaking the script flow for Mobile checks.
             // We skip click here to preserve state for Mobile check.
        } else {
             report.ui.push('Form detected but no visible submit button found on Desktop.');
        }
    }

    // --- MOBILE ANALYSIS (Ghost Button Check) ---
    console.log('\x1b[33m%s\x1b[0m', 'Running Mobile / Responsive Analysis (375x667)...');
    
    // Resize to iPhone SE-like viewport
    await page.setViewportSize({ width: 375, height: 667 });
    await page.waitForTimeout(500); // Allow layout to reflow

    // 5. Check for Horizontal Scroll (Overflow)
    const scrollWidth = await page.evaluate(() => document.body.scrollWidth);
    const clientWidth = await page.evaluate(() => document.body.clientWidth);
    
    if (scrollWidth > clientWidth) {
        report.ui.push(`MOBILE BREAK: Horizontal scroll detected (Content width: ${scrollWidth}px > Viewport: ${clientWidth}px). Fix CSS overflow.`);
    }

    // 6. Find Ghost Buttons (Broken on Mobile)
    // Re-query buttons in the new viewport context
    const mobileButtons = await page.getByRole('button').all();
    
    for (const btn of mobileButtons) {
        const text = (await btn.textContent())?.trim() || 'Unlabeled/Icon';
        const isVisible = await btn.isVisible();
        
        if (!isVisible) {
            // It was potentially visible on desktop (we handled that list separately), but if it's hidden now:
            // It might be intentional (desktop-only nav) or a bug.
            // We verify if it has a mobile alternative or if it's just broken.
            const display = await btn.evaluate(el => window.getComputedStyle(el).display);
            if (display !== 'none') {
                 report.ui.push(`MOBILE GHOST: Button "${text}" is theoretically visible (display: ${display}) but hidden by overlap or 0 size on mobile.`);
            }
        } else {
            // It IS visible, check if it's overlapping or clickable
            try {
                // Playwright's check: checks if element receives pointer events
                await btn.click({ trial: true, timeout: 500 }); 
            } catch (e) {
                report.ui.push(`MOBILE UNCLICKABLE: Button "${text}" is visible but covered by another element or unclickable on Mobile.`);
            }
        }
    }
    
    // Check for "Hamburger" menu existence if nav links are hidden
    const navLinks = await page.locator('nav a').count();
    const visibleNavLinks = await page.locator('nav a:visible').count();
    
    if (navLinks > 0 && visibleNavLinks === 0) {
        // High chance we need a hamburger menu. Check if one exists.
        // Heuristic: Button with "menu" in aria-label, class, or text
        const menuBtn = page.locator('button[aria-label*="menu"], button[class*="menu"], button:has-text("Menu"), [role="button"][class*="hamburger"]');
        if (await menuBtn.count() === 0) {
             report.ui.push('MOBILE UX: Navigation links are hidden, but no obvious "Menu/Hamburger" button was detected.');
        }
    }

  } catch (error) {
    report.critical.push(`Script Execution Error: ${error.message}`);
  } finally {
    await browser.close();
    generateMarkdown(report);
  }
})();

function generateMarkdown(data) {
    const content = `# DIAGNOSTIC LOG
Date: ${new Date().toISOString()}

## CRITICAL FAILURES
${data.critical.length ? data.critical.map(i => `- [ ] ${i}`).join('\n') : 'No critical failures detected.'}

## UI ISSUES (Desktop & Mobile)
${data.ui.length ? data.ui.map(i => `- [ ] ${i}`).join('\n') : 'No specific UI issues detected.'}

## LOGIC GAPS
${data.logic.length ? data.logic.map(i => `- [ ] ${i}`).join('\n') : 'No logic gaps detected.'}

## SECURITY WARNINGS
${data.security.length ? data.security.map(i => `- [ ] ${i}`).join('\n') : 'No security warnings detected.'}

--
*Generated by AuditIA Sonda*`;

    fs.writeFileSync('DIAGNOSTIC_LOG.md', content);
    console.log('\x1b[32m%s\x1b[0m', 'âœ… DIAGNOSTIC_LOG.md generated successfully.');
}
